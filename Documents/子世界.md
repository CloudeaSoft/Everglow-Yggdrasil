# 目录 <!-- omit in toc -->
- [整体介绍](#关于子世界的整体介绍)
- [属性与方法](#子世界的属性与方法)
  - [Width](#Width)
  - [Height](#Height)
  - [Tasks](#Tasks)
  - [Config](#Config)
  - [ShouldSave](#ShouldSave)
  - [NoPlayerSaving](#NoPlayerSaving)
  - [NormalUpdates](#NormalUpdates)
  - [SpecailPath](#SpecailPath)
  - [OnEnter](#OnEnter)
  - [OnExit](#OnExit)
  - [OnLoad](#OnLoad)
  - [OnUnload](#OnUnload)
  - [DrawSetup/DrawMenu](#DrawSetup/DrawMenu)
  - [GetLight](#GetLight)
- [额外相关](#额外相关)
  - [hideUnderworld](#hideUnderworld)
- [子世界的使用](#子世界的使用)
  - [#Enter](#Enter)
  - [#Exit](#Exit)
- [其他](#other)
  - [#关于Tasks](#关于Tasks)
  - [#关于回调链](#关于回调链)

# 关于子世界的整体介绍
此子世界支持是基于SubworldLibrary_v2.0.1_2022/6/19版本所改动的
由于IL部分的问题,此子世界支持与SubworldLibrary和任何强引用SubworldLibrary的模组冲突(目前无法解决)
主要的内容改动即解放了对世界大小的限制(虽然仍有一点点限制)
任何继承自Subworld的可实例化类将会被自动注册到SubworldSystem托管


# 子世界的属性与方法
Subworld具有一些属性和方法,用来确认和执行某些特定功能

# Width
这项属性决定了子世界的宽度,他应当为200的整数倍,且不少于800.当不满足该条件时将会被自动修正
例如700将被修正为800,8100将被修正为8200
当这个子世界具有存档时,无论该属性返回了何值,均会被弃用而使用存档内记录的宽度

#Height
这项属性决定了子世界的高度,他应当为150的整数倍,且不少于600.当不满足该条件时将会被自动修正
例如500将被修正为600,2150将被修正为2250
当这个子世界具有存档时,无论该属性返回了何值,均会被弃用而使用存档内记录的宽度

#Tasks
这项属性记录了世界的生成过程,将会依次遍历其中的生成任务并执行
也用于表示生成过程的进度等

#Config
这项属性具体不明,我还没看懂

#ShouldSave
这项属性控制这个子世界是否会被保存
如果为true,会在玩家创建世界时就执行生成
如果为false,这个子世界将不会执行保存,同样的,小地图也不会进行保存.生成将在玩家进入子世界时执行

#NoPlayerSaving
这项属性控制玩家在该子世界内是否会被保存
如果为true,玩家在该子世界内不会调用保存,不会增加存档的游戏时长
如果为false,则无影响

#NormalUpdates
这项属性控制一切常规更新
如果为false,那么
	时间将会被暂停(不再产生白天黑夜交替等)
	物块更新被停用(包括液体,帧图墙,TileEntity)
	玩家和NPC重力不再变化
	世界底部不会再蒸发水
如果为false,则无影响

#SpecailPath
这是一项文件路径重定向属性,以便于支持多个世界的子世界之间的文件转换
依靠此属性,你可以转换访问其他的正常世界(即将原版世界视为子世界进行加载,从而达到原世界穿越)
例如我本身存在两个世界文档,当我进入一个之后,将此属性返回另一个世界的文件路径,将另一个世界视为子世界
注意,在联机模式下此功能需要考虑同步问题

#OnEnter
这项重写方法在开始进入子世界但还未进入子世界时被唤起
唤起时还未处于子世界中,可以用来制作类似
	"当玩家进入了那个世界,污染也随之泄露,疯狂的意志扭曲了这片对它来说分外新鲜的土地"

#OnExit
这项重写方法在开始退出子世界但还未退出子世界时被唤起
唤起时还未离开子世界中,可以用来制作类似
	"光辉的英雄离开了这片被拯救的土地,然而阴影仍在不为人知的地方活动"

#OnLoad
这项重写方法在子世界已完成世界登入时被唤起
唤起时子世界的物块等已完成加载,相对于ModSystem更针对子世界(虽然二者功能是一样的,但是ModSystem还需要判定)

#OnUnload
这项重写方法在子世界已完成世界退出时被唤起
唤起时子世界的物块等已完成卸载,相对于ModSystem更针对子世界(虽然二者功能是一样的,但是ModSystem还需要判定)

#DrawSetup/DrawMenu
这两项重写构成了子世界进行载入时的表现
默认情况下时黑色底片绘制文字,但也可用于绘制些别的

#GetLight
此项重写将影响物块的光照,地表和地狱默认光,岩浆,火把等光照将不能照亮该物块

#额外相关
#hideUnderworld
SubworldSystem.hideUnderworld控制了和地下背景相关的内容
如果此项为false,背景墙等绘制将会被关闭,同时地下默认光照,玩家处于地下的判断也将关闭

#子世界的使用
#Enter
Enter包含两种方法,一个是直接以泛型T呼叫进入子世界,一个是以子世界的FullName呼叫进入子世界
返回值为true代表找到该子世界并开始进行进入(不代表一定成功)

#Exit
Exit方法被调用将退出全部子世界,返回最开始的原世界
无论进入多少子世界,原世界都会被确定为最开始进入的世界
如果你想制作链式回调,请自行继承Subworld并增加History和CallBackWorld方法


#other
#关于Tasks
Tasks接受继承GenPass的List作为返回值
如果为null则会导致异常,GenPass参考如下
    class MyGenPass : GenPass
    {
        private readonly IEnumerable<Action> Actions;
        public MyGenPass(string name, float loadWeight,params Action[] actions) : base(name, loadWeight)
        {
            Actions = actions ?? Array.Empty<Action>();
        }

        protected override void ApplyPass(GenerationProgress progress, GameConfiguration configuration)
        {
            Actions.ForEach(a => a());
        }
    }
但不建议如此将多个任务合并到一个GenPass中

#关于回调链
经过多次尝试之后还是决定放弃子世界全局的回调链
主要原因是玩家并不需要它
返回主世界代表玩家已经放弃或不想继续体验内容,一层层回调返回主世界显然是不适合的
世界回调是modder制作故事链的需求,应由modder具体实现,例如主要冒险世界和多层boss房的关系,甚至可能不是链条而是网络
我无法满足不可预期的链接结构,因此世界间的穿梭交由Subworld制作者自行具体实现